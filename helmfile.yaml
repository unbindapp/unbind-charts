repositories:
  - name: prometheus-community
    url: https://prometheus-community.github.io/helm-charts
  - name: postgres-operator
    url: https://opensource.zalando.com/postgres-operator/charts/postgres-operator
  - name: grafana
    url: https://grafana.github.io/helm-charts
  - name: dex
    url: https://charts.dexidp.io
  - name: ingress-nginx
    url: https://kubernetes.github.io/ingress-nginx
  - name: jetstack
    url: https://charts.jetstack.io
  - name: bitnami
    url: https://charts.bitnami.com/bitnami
  - name: fluxcd-community
    url: https://fluxcd-community.github.io/helm-charts
  - name: vm
    url: https://victoriametrics.github.io/helm-charts/

values:
 - unbindDomain: unbind.example.com
 - unbindRegistryDomain: unbind-registry.example.com
 - wildcardBaseDomain: ""
 - namespace: unbind-system
 - tlsSecretName: unbind-domain-tls
 - registryTlsSecretName: unbind-registry-domain-tls
 - unbindVersion: v0.0.20
 - externalRegistry:
     enabled: false
     host: docker.io
     username: ""
     password: ""

environments:
  default:
    values:
      - environments/default.yaml

helmDefaults:
  wait: false
  atomic: false
  timeout: 300
  createNamespace: true

hooks:
  - events: ["prepare"]
    showlogs: true
    command: "/bin/sh"
    args:
      - "-c"
      - |
        echo "Creating custom PriorityClass..."
        cat <<EOF | kubectl apply -f -
        apiVersion: scheduling.k8s.io/v1
        kind: PriorityClass
        metadata:
          name: unbind-high-priority
        value: 10000000
        globalDefault: false
        description: "High priority class for critical Unbind system components"
        EOF
        echo "PriorityClass 'unbind-high-priority' created successfully"

---
releases:
  - name: flux
    namespace: {{ .Values.namespace }}
    chart: fluxcd-community/flux2
    version: 2.15.0
    values:
      -
        policies:
          create: false
        helmController:
          create: true
          resources:
            requests:
              cpu: 10m
              memory: 10Mi
        sourceController:
          create: true
          resources:
            requests:
              cpu: 10m
              memory: 10Mi
        kustomizeController:
          create: false
        notificationController:
          create: false
        imageReflectionController:
          create: false
        imageAutomationController:
          create: false
    labels:
      component: flux
    installed: true

  - name: victoria-metrics-k8s-stack
    namespace: {{ .Values.namespace }}
    chart: vm/victoria-metrics-k8s-stack
    version: 0.50.1
    values:
      - values/victoria-metrics-k8s-stack.yaml
      - vmsingle:
          spec:
            retentionPeriod: {{ .Values | get "overrides.victoriaMetricsStack.retention" }}
            storage:
              accessModes: ["ReadWriteOnce"]
              resources:
                requests:
                  storage: {{ .Values | get "overrides.victoriaMetricsStack.storage" }}
    labels:
      component: monitoring
    installed: {{ .Values | get "components.victoriaMetricsStack.enabled" true }}

  - name: alloy
    namespace: {{ .Values.namespace }}
    chart: grafana/alloy
    version: 1.0.3
    values:
      -
        alloy:
          mounts:
            varlog: true
          configMap:
            content: |
              logging {
                level  = "info"
                format = "logfmt"
              }
              discovery.kubernetes "pods" {
                role = "pod"
                selectors {
                  role = "pod"
                  label = "unbind-team,unbind-project,unbind-environment,unbind-service,unbind-deployment"
                }
              }
              discovery.kubernetes "deployment_pods" {
                role = "pod"
                selectors {
                  role = "pod"
                  label = "unbind-deployment-build"
                }
              }
              discovery.relabel "pods" {
                targets = discovery.kubernetes.pods.targets
                rule {
                  action        = "replace"
                  source_labels = ["__meta_kubernetes_pod_label_unbind_team"]
                  target_label  = "unbind_team"
                }
                rule {
                  action        = "replace"
                  source_labels = ["__meta_kubernetes_pod_label_unbind_project"]
                  target_label  = "unbind_project"
                }
                rule {
                  action        = "replace"
                  source_labels = ["__meta_kubernetes_pod_label_unbind_environment"]
                  target_label  = "unbind_environment"
                }
                rule {
                  action        = "replace"
                  source_labels = ["__meta_kubernetes_pod_label_unbind_service"]
                  target_label  = "unbind_service"
                }
                rule {
                  action        = "replace"
                  source_labels = ["__meta_kubernetes_pod_label_unbind_deployment"]
                  target_label  = "unbind_deployment"
                }
              }
              discovery.relabel "deployment_pods" {
                targets = discovery.kubernetes.deployment_pods.targets
                rule {
                  action        = "replace"
                  source_labels = ["__meta_kubernetes_pod_label_unbind_deployment_build"]
                  target_label  = "unbind_deployment_build"
                }
              }
              loki.source.kubernetes "pods" {
                targets = discovery.relabel.pods.output
                forward_to = [loki.write.endpoint.receiver]
              }
              loki.source.kubernetes "deployment_pods" {
                targets = discovery.relabel.deployment_pods.output
                forward_to = [loki.write.endpoint.receiver]
              }
              loki.write "endpoint" {
                endpoint {
                  url = "http://{{ .Values | get "overrides.alloy.loki.endpoint.host" "loki-gateway" }}.{{ .Values | get "overrides.alloy.loki.namespace" .Values.namespace }}.svc.cluster.local:{{ .Values | get "overrides.alloy.loki.endpoint.port" "80" }}/loki/api/v1/push"
                  tenant_id = "local"
                }
              }

    labels:
      component: alloy
    installed: {{ .Values | get "components.alloy.enabled" true }}

  - name: loki
    namespace: {{ .Values.namespace }}
    chart: grafana/loki
    version: 6.30.1
    values:
      -
        loki:
          auth_enabled: false
          commonConfig:
            replication_factor: 1
          storage:
            type: filesystem
            bucketNames:
              chunks: chunks
              ruler: ruler
              admin: admin
          schemaConfig:
            configs:
              - from: "2024-04-01"
                store: tsdb
                object_store: filesystem
                schema: v13
                index:
                  prefix: loki_index_
                  period: 24h
          storage_config:
            filesystem:
              directory: /var/loki 
          pattern_ingester:
            enabled: true
          limits_config:
            # Reduce concurrent tail requests to save memory
            max_concurrent_tail_requests: 50
            allow_structured_metadata: true
            volume_enabled: true
            retention_period: {{ .Values | get "overrides.loki.retentionPeriod" }}
          compactor:
            working_directory: /var/loki
            retention_enabled: true
            retention_delete_delay: 2h
            retention_delete_worker_count: 1
            delete_request_store: filesystem
          ruler:
            enable_api: true
          tableManager:
            retention_deletes_enabled: true
            retention_period: {{ .Values | get "overrides.loki.retentionPeriod" }}

        resultsCache:
          enabled: false

        chunksCache:
          enabled: false

        lokiCanary:
          enabled: false

        test:
          enabled: false

        minio:
          enabled: false

        deploymentMode: SingleBinary
        singleBinary:
          replicas: 1
          persistence:
            enabled: true
            size: {{ .Values | get "overrides.loki.lokiStorageSize" }}

        backend:
          replicas: 0
        read:
          replicas: 0
        write:
          replicas: 0
        ingester:
          replicas: 0
        querier:
          replicas: 0
        queryFrontend:
          replicas: 0
        queryScheduler:
          replicas: 0
        distributor:
          replicas: 0
        compactor:
          replicas: 0
        indexGateway:
          replicas: 0
        bloomCompactor:
          replicas: 0
        bloomGateway:
          replicas: 0

    labels:
      component: loki
    installed: {{ .Values | get "components.loki.enabled" true }}

  - name: buildkit
    namespace: {{ .Values.namespace }}
    chart: ./charts/buildkitd
    values:
      -
        resources: {}
        replicaCount: {{ .Values | get "overrides.buildkitd.replicas" }}
        image: {{ .Values | get "overrides.buildkitd.image" }}

    labels:
      component: build
    installed: {{ .Values | get "components.buildkitd.enabled" true }}

  - name: postgres-operator
    namespace: {{ .Values.namespace }}
    chart: postgres-operator/postgres-operator
    version: 1.14.0
    hooks:
      - events: ["presync"]
        showlogs: true
        command: "/bin/sh"
        args:
          - "-c"
          - |
            echo "Installing Postgres Operator CRDs..."
            kubectl apply -f https://raw.githubusercontent.com/zalando/postgres-operator/refs/tags/v1.14.0/manifests/operatorconfiguration.crd.yaml
            kubectl apply -f https://raw.githubusercontent.com/zalando/postgres-operator/refs/tags/v1.14.0/manifests/postgresql.crd.yaml
            echo "Postgres Operator CRDs installed"
    values:
      -
        configGeneral:
          docker_image: {{ .Values | get "overrides.postgresOperator.spiloImage" }}
        resources:
          limits:
            cpu: 500m
            memory: 500Mi
          requests:
            cpu: 10m
            memory: 50Mi
        configKubernetes:
          inherited_labels:
            - unbind-team
            - unbind-project
            - unbind-environment
            - unbind-service
            - unbind-deployment
            - unbind-is-system-db
            - app.kubernetes.io/managed-by
            - app.kubernetes.io/name
            - app.kubernetes.io/instance
            - app.kubernetes.io/version
            - helm.sh/chart
            - unbind/usd-name
            - unbind/usd-version
            - unbind/usd-category

    labels:
      component: postgres-operator
    installed: {{ .Values | get "components.postgresOperator.enabled" true }}

  - name: database
    namespace: {{ .Values.namespace }}
    chart: ./charts/database
    needs:
      - postgres-operator
    values:
      -
        replicaCount: {{ .Values | get "overrides.database.replicaCount" }}
        storage: {{ .Values | get "overrides.database.storage" }}
        resources:
          requests:
            memory: "10Mi"
            cpu: "10m"
          limits:
            cpu: {{ .Values | get "overrides.database.resources.limits.cpu" }}
            memory: {{ .Values | get "overrides.database.resources.limits.memory" }}
    labels:
      component: database
    installed: {{ .Values | get "components.database.enabled" true }}

  - name: redis
    namespace: {{ .Values.namespace }}
    chart: bitnami/redis
    version: 21.1.8
    values:
      - architecture: standalone
        auth:
          enabled: false
        commonConfiguration: |-
          appendonly yes
          protected-mode no
        master:
          replicaCount: 1
          persistence:
            enabled: true
            size: 512Mi
          resourcesPreset: "none"
          resources:
            requests:
              memory: 10Mi
              cpu: 10m
            limits:
              memory: 192Mi
              cpu: 150m
        replica:
          replicaCount: 0
    labels:
      component: redis
    installed: {{ .Values | get "components.redis.enabled" true }}

  - name: registry
    namespace: {{ .Values.namespace }}
    chart: ./charts/registry
    hooks:
      - events: ["presync"]
        showlogs: true
        command: "/bin/sh"
        args:
          - "-c"
          - |
            set -eu
            NAMESPACE="{{ .Values.namespace }}"
            GREEN='\033[0;32m'
            NC='\033[0m'
            YELLOW='\033[0;33m'
            RED='\033[0;31m'

            retry_command() {
              local max_attempts=30
              local attempt=1
              local timeout=3
              local command="$@"

              while true; do
                echo -e "${YELLOW}Attempt $attempt/$max_attempts: Running command...${NC}"
                if eval "$command"; then
                  return 0
                fi

                attempt=$((attempt + 1))
                if [ $attempt -gt $max_attempts ]; then
                  echo -e "${RED}Command failed after $max_attempts attempts${NC}"
                  return 1
                fi

                echo -e "${YELLOW}Command failed. Retrying in $timeout seconds...${NC}"
                sleep $timeout
                timeout=$((timeout + 2))
              done
            }

            echo "Checking for namespace '$NAMESPACE'..."
            if ! kubectl get namespace "$NAMESPACE" &>/dev/null; then
              echo -e "${YELLOW}Namespace '$NAMESPACE' not found. Waiting for it to be created (up to 5 minutes)...${NC}"
              if ! retry_command "kubectl get namespace \"$NAMESPACE\" &>/dev/null"; then
                echo -e "${RED}Namespace '$NAMESPACE' was never created. Exiting.${NC}"
                exit 1
              fi
            fi
            echo -e "${GREEN}âœ“ Namespace '$NAMESPACE' exists${NC}"

            echo "Checking for existing secret 'registry-basic-auth' in namespace '$NAMESPACE'..."
            if ! kubectl get secret registry-basic-auth -n "$NAMESPACE" &> /dev/null; then
              echo "Creating basic auth secret for Docker Registry..."
              TMPFILE=$(mktemp)
              trap 'rm -f -- "$TMPFILE"' EXIT

              USERNAME={{ .Values | get "overrides.registry.auth.username" "admin" }}
              PASSWORD=$(openssl rand -base64 48 | tr -d '\n')

              htpasswd -Bbn "$USERNAME" "$PASSWORD" > "$TMPFILE"

              echo "Creating registry-basic-auth secret..."
              if ! retry_command "kubectl create secret generic registry-basic-auth --namespace=\"$NAMESPACE\" --from-file=auth=\"$TMPFILE\""; then
                echo -e "${RED}Failed to create registry-basic-auth secret after multiple attempts${NC}"
                exit 1
              fi

              echo "Creating registry-credentials secret..."
              if ! retry_command "kubectl create secret generic registry-credentials --namespace=\"$NAMESPACE\" --from-literal=username=\"${USERNAME}\" --from-literal=password=\"${PASSWORD}\""; then
                echo -e "${RED}Failed to create registry-credentials secret after multiple attempts${NC}"
                exit 1
              fi

              echo -e "${GREEN}âœ“ Registry secrets created.${NC}"
            else
              echo "Secret registry-basic-auth already exists in namespace $NAMESPACE."
            fi
    values:
      -
        ingress:
          enabled: true
          host: {{ .Values.unbindRegistryDomain }}
          authSecret: registry-basic-auth
          tls:
            secretName: {{ .Values.registryTlsSecretName }}
        replicaCount: {{ .Values | get "overrides.registry.replicaCount" }}
        persistence:
          size: {{ .Values | get "overrides.registry.persistence.size" }}
        cleanup:
          threshold: {{ .Values | get "overrides.registry.cleanup.threshold" }}

    # Update the labels in registry component
    labels:
      component: registry
    installed: {{ if .Values | get "externalRegistry.enabled" false }}false{{ else }}{{ .Values | get "components.registry.enabled" true }}{{ end }}

  - name: ingress-nginx
    namespace: {{ .Values.namespace }}
    chart: ingress-nginx/ingress-nginx
    version: 4.12.2
    values:
      -
        controller:
          priorityClassName: unbind-high-priority
          kind: DaemonSet
          allowSnippetAnnotations: true
          image:
            registry: registry.k8s.io
            image: ingress-nginx/controller
            tag: "v1.12.2"
            digest: sha256:d2fbc4ec70d8aa2050dd91a91506e998765e86c96f32cffb56c503c9c34eed5b
          ingressClassResource:
            name: nginx
            default: true
          admissionWebhooks:
            enabled: false
          service:
            enabled: true
            type: LoadBalancer
            externalTrafficPolicy: Local
          config:
            use-forwarded-headers: "true"
            compute-full-forwarded-for: "true"
            use-proxy-protocol: "false"
            annotations-risk-level: "Critical"
          resources:
            requests:
              cpu: 10m
              memory: 10Mi
        rbac:
          create: true
          scope: false
        serviceAccount:
          create: true
    labels:
      component: ingress
    installed: {{ .Values | get "components.ingressNginx.enabled" true }}

  - name: cert-manager
    namespace: {{ .Values.namespace }}
    chart: jetstack/cert-manager
    version: 1.17.2
    hooks:
      - events: ["presync"]
        showlogs: true
        command: "/bin/sh"
        args:
          - "-c"
          - |
            echo "Installing cert-manager CRDs..."
            kubectl apply -f https://github.com/cert-manager/cert-manager/releases/download/v1.17.1/cert-manager.crds.yaml
            echo "Cert-manager CRDs installed"
      - events: ["postsync"]
        showlogs: true
        command: "/bin/sh"
        args:
          - "-c"
          - |
            cat <<EOF | kubectl apply -f -
            apiVersion: cert-manager.io/v1
            kind: ClusterIssuer
            metadata:
              name: letsencrypt-prod
            spec:
              acme:
                server: https://acme-v02.api.letsencrypt.org/directory
                email: "admin@{{ .Values.unbindDomain }}"
                privateKeySecretRef:
                  name: letsencrypt-prod
                solvers:
                - http01:
                    ingress:
                      class: nginx
            EOF
    values:
      -
        crds:
          enabled: false
        replicaCount: {{ .Values | get "overrides.certManager.replicaCount" 1 }}
        ingressShim:
          defaultIssuerName: letsencrypt-prod
          defaultIssuerKind: ClusterIssuer
          defaultIssuerGroup: cert-manager.io
    labels:
      component: cert-manager
    installed: {{ .Values | get "components.certManager.enabled" true }}

  - name: dex
    namespace: {{ .Values.namespace }}
    chart: dex/dex
    version: 0.23.0
    needs:
      - database
      - cert-manager
    hooks:
      - events: ["presync"]
        showlogs: true
        command: "/bin/sh"
        args:
          - "-c"   
          - |
            set -eu

            NAMESPACE="{{ .Values.namespace }}"
            UNBIND_DOMAIN="{{ .Values.unbindDomain }}"
            GREEN='\033[0;32m'
            NC='\033[0m'
            YELLOW='\033[0;33m'

            safe_create_secret() {
              local name="$1"
              shift
              echo "Ensuring $name secret exists..."
              if kubectl create "$@" >/dev/null 2>&1; then
                echo -e "${GREEN}âœ“ Created $name secret${NC}"
                return 0
              else
                if kubectl get secret "$name" -n "$NAMESPACE" &>/dev/null; then
                  echo -e "${YELLOW}$name secret already exists. Skipping creation.${NC}"
                  return 0
                else
                  echo "Error: Failed to create $name secret and it does not exist. Check permissions or kubectl logs." >&2
                  return 1
                fi
              fi
            }

            echo "Processing dex-client-secrets..."
            CLIENT_SECRET=$(openssl rand -base64 32 | tr -dc 'a-zA-Z0-9' | fold -w 24 | head -n 1)
            CONNECTOR_SECRET=$(openssl rand -base64 32 | tr -dc 'a-zA-Z0-9' | fold -w 24 | head -n 1)

            safe_create_secret "dex-client-secrets" \
              secret generic dex-client-secrets \
              --namespace="$NAMESPACE" \
              --from-literal=unbind-api-secret="${CLIENT_SECRET}" \
              --from-literal=connector-oidc-secret="${CONNECTOR_SECRET}"

            echo "Processing dex-tls secret..."
            if ! kubectl get secret dex-tls -n "$NAMESPACE" &> /dev/null; then
              echo "Generating TLS certificates for Dex (internal use)..."

              CERT_DIR=$(mktemp -d)
              trap 'rm -rf -- "$CERT_DIR"' EXIT

              DEX_SVC_NAME="dex"
              DEX_SVC_FQDN="${DEX_SVC_NAME}.${NAMESPACE}.svc.cluster.local"
              DEX_EXTERNAL_HOST="{{ .Values.unbindDomain }}"

              echo "Generating Root CA..."
              openssl genrsa -out "$CERT_DIR/ca.key" 4096
              openssl req -x509 -new -nodes -key "$CERT_DIR/ca.key" -sha256 -days 6650 \
                -out "$CERT_DIR/ca.crt" -subj "/CN=Unbind Dex Internal CA"

              echo "Generating certificate for Dex service..."
              openssl genrsa -out "$CERT_DIR/dex.key" 2048
              openssl req -new -key "$CERT_DIR/dex.key" -out "$CERT_DIR/dex.csr" \
                -subj "/CN=$DEX_SVC_FQDN"

              printf '%s\n' \
                'authorityKeyIdentifier=keyid,issuer' \
                'basicConstraints=CA:FALSE' \
                'keyUsage = digitalSignature, nonRepudiation, keyEncipherment, dataEncipherment' \
                'subjectAltName = @alt_names' \
                '[alt_names]' \
                "DNS.1 = $DEX_SVC_NAME" \
                "DNS.2 = $DEX_SVC_FQDN" \
                "DNS.3 = $DEX_EXTERNAL_HOST" \
                > "$CERT_DIR/dex.ext"

              echo "Signing Dex certificate..."
              openssl x509 -req -in "$CERT_DIR/dex.csr" -CA "$CERT_DIR/ca.crt" -CAkey "$CERT_DIR/ca.key" \
                -CAcreateserial -out "$CERT_DIR/dex.crt" -days 6650 -sha256 \
                -extfile "$CERT_DIR/dex.ext"
              echo -e "${GREEN}âœ“ Certificates generated${NC}"

              safe_create_secret "dex-tls" \
                secret tls dex-tls \
                --namespace="$NAMESPACE" \
                --cert="$CERT_DIR/dex.crt" \
                --key="$CERT_DIR/dex.key"

              if kubectl get secret dex-tls -n "$NAMESPACE" &> /dev/null; then
                CA_CRT_BASE64=$(base64 -w 0 < "$CERT_DIR/ca.crt")

                echo "Patching dex-tls secret to include ca.crt..."
                kubectl patch secret dex-tls -n "$NAMESPACE" --type='json' \
                  -p="[{\"op\": \"add\", \"path\": \"/data/ca.crt\", \"value\": \"$CA_CRT_BASE64\"}]" || \
                  echo -e "${YELLOW}Warning: Failed to patch dex-tls secret with CA certificate.${NC}"

                echo -e "${GREEN}âœ“ TLS certificates for Dex processed${NC}"
              fi
            else
              echo -e "${YELLOW}Internal TLS secret dex-tls already exists.${NC}"
            fi

            echo "Dex secrets/certs processing complete."
    values:
      -
        image:
          repository: unbindapp/dex
          tag: master-14777142866
          pullPolicy: IfNotPresent

        replicaCount: {{ .Values | get "overrides.dex.replicaCount" 2 }}

        priorityClassName: unbind-high-priority

        https:
          enabled: true

        configSecret:
          create: true

        config:
          issuer: {{ .Values | get "overrides.dex.issuer" (printf "https://%s/api/dex" .Values.unbindDomain) }}
          storage:
            type: postgres
            config:
              host: {{ .Values | get "overrides.dex.postgres.host" (printf "pg-unbind.%s" .Values.namespace) }}
              port: {{ .Values | get "overrides.dex.postgres.port" 5432 }}
              database: {{ .Values | get "overrides.dex.postgres.database" "dex" }}
              user: {{ printf "$%s" "POSTGRES_USER" }}
              password: {{ printf "$%s" "POSTGRES_PASSWORD" }}
              ssl:
                mode: {{ .Values | get "overrides.dex.postgres.ssl.mode" "disable" }}
          web:
            https: 0.0.0.0:5556
            tlsCert: /etc/dex/tls/tls.crt
            tlsKey: /etc/dex/tls/tls.key
          issuers: {{ .Values | get "overrides.dex.issuers" (list (printf "https://%s/api/dex" .Values.unbindDomain) (printf "https://dex.%s.svc.cluster.local:5556" .Values.namespace)) | toYaml | nindent 12 }}
          oauth2:
            skipApprovalScreen: {{ .Values | get "overrides.dex.oauth2.skipApprovalScreen" true }}
            responseTypes: {{ .Values | get "overrides.dex.oauth2.responseTypes" (list "code") | toYaml | nindent 14 }}
            alwaysIssueOfflineToken: {{ .Values | get "overrides.dex.oauth2.alwaysIssueOfflineToken" true }}
          expiry:
            idTokens: {{ .Values | get "overrides.dex.expiry.idTokens" "1h" }}
            accessTokens: {{ .Values | get "overrides.dex.expiry.accessTokens" "1h" }}
            refreshTokens:
              validIfNotUsedFor: {{ .Values | get "overrides.dex.expiry.refreshTokens.validIfNotUsedFor" "336h" }}
              disableRotation: {{ .Values | get "overrides.dex.expiry.refreshTokens.disableRotation" true }}
          connectors:
            {{ .Values | get "overrides.dex.connectors" (list (dict
              "type" "oidc"
              "id" "unbind-oidc"
              "name" "Unbind Built-in OIDC Provider"
              "config" (dict
                "issuer" (printf "https://%s/api/oauth2" .Values.unbindDomain)
                "clientID" "dex-client"
                "clientSecret" (printf "$%s" "CONNECTOR_SECRET")
                "redirectURI" (printf "https://%s/api/dex/callback" .Values.unbindDomain)
                "scopes" (list "openid" "profile" "email" "offline_access" "groups")
                "insecureEnableGroups" true
                "discoveryURL" (printf "https://%s/api/oauth2/.well-known/openid-configuration" .Values.unbindDomain)
                "userIDKey" "jti"
                "claimMapping" (dict "email" "email" "name" "name" "groups" "groups")
              )
            )) | toYaml | nindent 12 }}
          staticClients:
            - id: unbind-api
              secretEnv: CLIENT_SECRET
              name: Unbind API
              redirectURIs:
                - {{ printf "https://%s/api-internal/auth/callback/dex" .Values.unbindDomain }}
                - {{ printf "https://%s/api/auth/callback" .Values.unbindDomain }}
              responseTypes: {{ .Values | get "overrides.dex.staticClients.unbindApi.responseTypes" (list "code") | toYaml | nindent 16 }}

        envVars:
          - name: POSTGRES_USER
            valueFrom:
              secretKeyRef:
                name: {{ .Values | get "overrides.dex.postgres.secretName" "dex.pg-unbind.credentials.postgresql.acid.zalan.do" }}
                key: username
          - name: POSTGRES_PASSWORD
            valueFrom:
              secretKeyRef:
                name: {{ .Values | get "overrides.dex.postgres.secretName" "dex.pg-unbind.credentials.postgresql.acid.zalan.do" }}
                key: password
          - name: CLIENT_SECRET
            valueFrom:
              secretKeyRef:
                name: dex-client-secrets
                key: unbind-api-secret
          - name: CONNECTOR_SECRET
            valueFrom:
              secretKeyRef:
                name: dex-client-secrets
                key: connector-oidc-secret

        securityContext:
          runAsNonRoot: true
          runAsUser: 1000

        resources:
          requests:
            memory: "10Mi"
            cpu: "10m"
          limits:
            cpu: {{ .Values | get "overrides.dex.resources.limits.cpu" "200m" }}
            memory: {{ .Values | get "overrides.dex.resources.limits.memory" "256Mi" }}

        ingress:
          enabled: {{ .Values | get "overrides.dex.ingress.enabled" true }}
          className: {{ .Values | get "overrides.dex.ingress.className" "nginx" }}
          annotations:
            kubernetes.io/tls-acme: "true"
            nginx.ingress.kubernetes.io/ssl-redirect: "true"
            {{- with .Values | get "overrides.dex.ingress.annotations" dict }}
            {{- toYaml . | nindent 12 }}
            {{- end }}
          hosts:
            - host: {{ .Values.unbindDomain }}
              paths:
                - path: /api/dex
                  pathType: Prefix
          tls:
            - secretName: {{ .Values.tlsSecretName }}
              hosts:
                - {{ .Values.unbindDomain }}

        volumes:
          - name: tls-certs
            secret:
              secretName: dex-tls

        volumeMounts:
          - name: tls-certs
            mountPath: /etc/dex/tls
            readOnly: true

    labels:
      component: dex
    installed: {{ .Values | get "components.dex.enabled" true }}

  - name: kube-oidc-proxy
    namespace: {{ .Values.namespace }}
    chart: ./charts/kube-oidc-proxy
    needs:
      - dex
    values:
      -
        replicaCount: {{ .Values | get "overrides.kubeOidcProxy.replicaCount" 2 }}
        image:
          repository: {{ .Values | get "overrides.kubeOidcProxy.image.repository" "ghcr.io/unbindapp/kube-oidc-proxy" }}
          tag: {{ .Values | get "overrides.kubeOidcProxy.image.tag" "master-14884925050" }}
          pullPolicy: {{ .Values | get "overrides.kubeOidcProxy.image.pullPolicy" "IfNotPresent" }}

        oidc:
          issuerUrl: {{ .Values | get "overrides.kubeOidcProxy.oidc.issuerUrl" (printf "https://%s/api/dex" .Values.unbindDomain) }}
          clientId: {{ .Values | get "overrides.kubeOidcProxy.oidc.clientId" "unbind-api" }}
          usernameClaim: {{ .Values | get "overrides.kubeOidcProxy.oidc.usernameClaim" "email" }}
          groupsClaim: {{ .Values | get "overrides.kubeOidcProxy.oidc.groupsClaim" "groups" }}

        service:
          type: {{ .Values | get "overrides.kubeOidcProxy.service.type" "ClusterIP" }}
          port: {{ .Values | get "overrides.kubeOidcProxy.service.port" 443 }}
          targetPort: {{ .Values | get "overrides.kubeOidcProxy.service.targetPort" 443 }}

        resources:
          requests:
            memory: "10Mi"
            cpu: "10m"
          limits:
            cpu: {{ .Values | get "overrides.kubeOidcProxy.resources.limits.cpu" "300m" }}
            memory: {{ .Values | get "overrides.kubeOidcProxy.resources.limits.memory" "256Mi" }}

        rbac:
          create: {{ .Values | get "overrides.kubeOidcProxy.rbac.create" true }}
          viewerCreate: {{ .Values | get "overrides.kubeOidcProxy.rbac.viewerCreate" true }}
          viewerGroupName: {{ .Values | get "overrides.kubeOidcProxy.rbac.viewerGroupName" "oidc:users" }}

    labels:
      component: auth
    installed: {{ .Values | get "components.kubeOidcProxy.enabled" true }}

  - name: unbind-operator
    namespace: {{ .Values.namespace }}
    chart: ./charts/unbind-operator
    values:
      -
        controllerManager:
          container:
            image:
              repository: {{ .Values | get "overrides.unbind.operator.repository" "ghcr.io/unbindapp/unbind-operator" }}
              tag: {{ .Values.unbindVersion }}
    labels:
      component: unbind-operator
    installed: true

  - name: unbind-app
    namespace: '{{ .Values.namespace }}'
    chart: ./charts/unbind
    wait: true
    atomic: true  
    timeout: 900
    needs:
      - redis
      - database
      - cert-manager
    hooks:
      - events: ["postsync"]   
        showlogs: true                         
        command: "/bin/sh"
        args:
          - "-c"
          - |
            NS="{{ .Values.namespace }}"
            echo "ðŸ”„  Restarting Dex deployments in namespace ${NS} â€¦"

            # 1. Try the modern rollout-restart (preferred, respects deployment strategy)
            if kubectl -n "${NS}" rollout restart deployment \
                -l app.kubernetes.io/instance=dex; then
              echo "âœ…  Dex restart triggered with 'kubectl rollout restart'"
            fi
      - events: ["presync"]
        showlogs: true
        command: "/bin/sh"
        args:
          - "-c"
          - |
            set -eu

            NAMESPACE="{{ .Values.namespace }}"
            GREEN='\033[0;32m'
            NC='\033[0m'
            YELLOW='\033[0;33m'
            EXTERNAL_REGISTRY_ENABLED="{{ .Values | get "externalRegistry.enabled" false }}"

            safe_create_secret() {
              local name="$1"
              shift

              echo "Ensuring $name secret exists..."
              if kubectl create secret "$@" >/dev/null 2>&1; then
                echo -e "${GREEN}âœ“ Created $name secret${NC}"
                return 0
              else
                if kubectl get secret "$name" -n "$NAMESPACE" &>/dev/null; then
                  echo -e "${YELLOW}$name secret already exists. Skipping creation.${NC}"
                  return 0
                else
                  echo "Error: Failed to create $name secret and it does not exist. Check permissions or kubectl logs." >&2
                  return 1
                fi
              fi
            }

            echo "Processing unbind-authjs-secrets..."
            AUTH_SECRET=$(openssl rand -base64 32 | tr -dc 'a-zA-Z0-9' | fold -w 24 | head -n 1)

            if ! safe_create_secret "unbind-authjs-secrets" generic unbind-authjs-secrets \
              --namespace="$NAMESPACE" \
              --from-literal=auth-secret="${AUTH_SECRET}"; then
              echo "Error: Failed to ensure unbind-authjs-secrets exists. Halting hook." >&2
              exit 1
            fi

            echo "Processing dex-client-secrets..."
            CLIENT_SECRET=$(openssl rand -base64 32 | tr -dc 'a-zA-Z0-9' | fold -w 24 | head -n 1)
            CONNECTOR_SECRET=$(openssl rand -base64 32 | tr -dc 'a-zA-Z0-9' | fold -w 24 | head -n 1)

            if ! safe_create_secret "dex-client-secrets" generic dex-client-secrets \
              --namespace="$NAMESPACE" \
              --from-literal=unbind-api-secret="${CLIENT_SECRET}" \
              --from-literal=connector-oidc-secret="${CONNECTOR_SECRET}"; then
              echo "Error: Failed to ensure dex-client-secrets exists. Halting hook." >&2
              exit 1
            fi

            if [ "$EXTERNAL_REGISTRY_ENABLED" = "true" ]; then
              echo "Using external registry. Creating registry credentials..."
              
              # Get external registry credentials
              REGISTRY_HOST="{{ .Values | get "externalRegistry.host" "docker.io" }}"
              REGISTRY_USERNAME="{{ .Values | get "externalRegistry.username" "" }}"
              REGISTRY_PASSWORD="{{ .Values | get "externalRegistry.password" "" }}"
              
              # Create registry credentials for external registry using retry logic
              echo "Creating registry-credentials secret for external registry..."
              if ! safe_create_secret "registry-credentials" generic registry-credentials \
                --namespace="$NAMESPACE" \
                --from-literal=username="${REGISTRY_USERNAME}" \
                --from-literal=password="${REGISTRY_PASSWORD}"; then
                echo "Error: Failed to ensure registry-credentials exists for external registry. Halting hook." >&2
                exit 1
              fi
              
              echo -e "${GREEN}Registry credentials created for external registry: $REGISTRY_HOST${NC}"
              exit 0
            fi

            echo "Secret checks/creation complete."
    values:
      - global:
          namespace: '{{ .Values.namespace }}'

      - ingress:
          enabled: true
          host: {{ .Values.unbindDomain }}
          className: {{ .Values | get "overrides.ingress.className" "nginx" }}
          annotations:
             kubernetes.io/tls-acme: "true"
             nginx.ingress.kubernetes.io/ssl-redirect: "true"
          tls:
            secretName: {{ .Values.tlsSecretName }}

      - ui:
          enabled: true
          name: unbind-ui
          image:
            repository: {{ .Values | get "overrides.unbind.ui.repository" "ghcr.io/unbindapp/unbind-ui" }}
            tag: {{ .Values.unbindVersion }}
            pullPolicy: {{ .Values | get "overrides.unbind.ui.pullPolicy" "Always" }}
          replicaCount: {{ .Values | get "overrides.unbind.ui.replicaCount" 2 }}
          resources:
            requests:
              memory: "128Mi"
              cpu: "50m"
            limits:
              cpu: {{ .Values | get "overrides.unbind.ui.resources.limits.cpu" "500m" }}
              memory: {{ .Values | get "overrides.unbind.ui.resources.limits.memory" "1Gi" }}
          containerPort: 3000
          service:
            type: ClusterIP
            port: 3000
          ingress:
            enabled: true
          env:
            - name: AUTH_SECRET
              valueFrom:
                secretKeyRef:
                  name: unbind-authjs-secrets
                  key: auth-secret
            - name: AUTH_URL
              value: {{ printf "https://%s/api-internal/auth" .Values.unbindDomain }}
            - name: DEX_CLIENT_ID
              value: {{ .Values | get "overrides.unbind.ui.dex.clientId" "unbind-api" }}
            - name: DEX_CLIENT_SECRET
              valueFrom:
                secretKeyRef:
                  name: {{ .Values | get "overrides.unbind.ui.dex.secretName" "dex-client-secrets" }}
                  key: {{ .Values | get "overrides.unbind.ui.dex.secretKey" "unbind-api-secret" }}
            - name: DEX_ISSUER
              value: {{ printf "https://%s/api/dex" .Values.unbindDomain }}
            - name: UNBIND_API_EXTERNAL_URL
              value: {{ printf "https://%s/api/go" .Values.unbindDomain }}
            - name: UNBIND_API_INTERNAL_URL
              value: {{ printf "http://unbind-api.%s.svc.cluster.local:8089" .Values.namespace }}
            - name: SITE_URL
              value: {{ printf "https://%s" .Values.unbindDomain }}

      - api:
          enabled: true
          name: unbind-api
          image:
            repository: {{ .Values | get "overrides.unbind.api.repository" "ghcr.io/unbindapp/unbind-api" }}
            tag: {{ .Values.unbindVersion }}
            pullPolicy: {{ .Values | get "overrides.unbind.api.pullPolicy" "Always" }}
          replicaCount: {{ .Values | get "overrides.unbind.api.replicaCount" 2 }}
          resources:
            requests:
              memory: "10Mi"
              cpu: "50m"
            limits:
              cpu: {{ .Values | get "overrides.unbind.api.resources.limits.cpu" "500m" }}
              memory: {{ .Values | get "overrides.unbind.api.resources.limits.memory" "2Gi" }}
          containerPort: 8089
          service:
            type: ClusterIP
            port: 8089
          ingress:
            enabled: true
          command: ["/app/api"]
          env:
            - name: SYSTEM_NAMESPACE
              value: {{ .Values.namespace }}
            - name: EXTERNAL_UI_URL
              value: {{ printf "https://%s" .Values.unbindDomain }}
            - name: EXTERNAL_API_URL
              value: {{ printf "https://%s/api/go" .Values.unbindDomain }}
            - name: EXTERNAL_OAUTH2_URL
              value: {{ printf "https://%s/api/oauth2" .Values.unbindDomain }}
            {{- if ne .Values.wildcardBaseDomain "" }}
            - name: BOOTSTRAP_WILDCARD_BASE_URL
              value: {{ printf "https://%s" .Values.wildcardBaseDomain }}
            {{- end }}
            - name: POSTGRES_HOST
              value: {{ .Values | get "overrides.unbind.api.database.host" (printf "pg-unbind.%s" .Values.namespace) }}
            - name: POSTGRES_PORT
              value: {{ .Values | get "overrides.unbind.api.database.port" "5432" | quote }}
            - name: POSTGRES_USER
              valueFrom:
                secretKeyRef:
                  name: {{ .Values | get "overrides.unbind.api.database.secretName" "unbind.pg-unbind.credentials.postgresql.acid.zalan.do" }}
                  key: username
            - name: POSTGRES_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: {{ .Values | get "overrides.unbind.api.database.secretName" "unbind.pg-unbind.credentials.postgresql.acid.zalan.do" }}
                  key: password
            - name: POSTGRES_DB
              value: {{ .Values | get "overrides.unbind.api.database.name" "unbind" }}
            - name: REDIS_URL
              value: {{ .Values | get "overrides.unbind.api.redis.url" (printf "redis-headless.%s:6379" .Values.namespace) }}
            - name: DEX_ISSUER_URL
              value: {{ .Values | get "overrides.unbind.api.dex.issuerUrl" (printf "https://%s/api/dex" .Values.unbindDomain) }}
            - name: DEX_ISSUER_URL_EXTERNAL
              value: {{ .Values | get "overrides.unbind.api.dex.issuerUrlExternal" (printf "https://%s/api/dex" .Values.unbindDomain) }}
            - name: DEX_CLIENT_ID
              value: {{ .Values | get "overrides.unbind.api.dex.clientId" "unbind-api" }}
            - name: DEX_CLIENT_SECRET
              valueFrom:
                secretKeyRef:
                  name: {{ .Values | get "overrides.unbind.api.dex.secretName" "dex-client-secrets" }}
                  key: {{ .Values | get "overrides.unbind.api.dex.secretKey" "unbind-api-secret" }}
            - name: KUBE_PROXY_URL
              value: {{ .Values | get "overrides.unbind.api.kubeProxyUrl" (printf "https://kube-oidc-proxy.%s.svc.cluster.local:443" .Values.namespace) }}
            - name: BUILDER_NAMESPACE
              value: {{ .Values.namespace }}
            - name: BOOTSTRAP_CONTAINER_REGISTRY_HOST
              value: {{ if .Values | get "externalRegistry.enabled" false }}{{ .Values | get "externalRegistry.host" "docker.io" }}{{ else }}{{ .Values | get "overrides.unbind.api.registry.host" .Values.unbindRegistryDomain }}{{ end }}
            - name: BOOTSTRAP_CONTAINER_REGISTRY_USER
              valueFrom:
                secretKeyRef:
                  name: registry-credentials
                  key: username
            - name: BOOTSTRAP_CONTAINER_REGISTRY_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: registry-credentials
                  key: password
            - name: BUILDKIT_HOST
              value: {{ $hostValue := .Values | get "overrides.unbind.api.buildkit.host" "" }}
                    {{- if $hostValue }}
                    {{- $hostValue }}
                    {{- else }}
                    {{- printf "tcp://buildkit.%s:1234" .Values.namespace }}
                    {{- end }}
            - name: LOKI_ENDPOINT
              value: {{ .Values | get "overrides.unbind.api.loki.endpoint" (printf "http://loki-gateway.%s.svc.cluster.local" .Values.namespace) }}
            - name: PROMETHEUS_ENDPOINT
              value: {{ .Values | get "overrides.unbind.api.prometheus.endpoint" (printf "http://vmsingle-victoria-metrics-k8s-stack.%s:8429" .Values.namespace) }}

      - auth:
          enabled: true
          name: unbind-auth
          image:
            repository: {{ .Values | get "overrides.unbind.auth.repository" "ghcr.io/unbindapp/unbind-api" }}
            tag: {{ .Values.unbindVersion }}
            pullPolicy: {{ .Values | get "overrides.unbind.auth.pullPolicy" "Always" }}
          replicaCount: {{ .Values | get "overrides.unbind.auth.replicaCount" 2 }}
          resources:
            requests:
              memory: "10Mi"
              cpu: "50m"
            limits:
              cpu: {{ .Values | get "overrides.unbind.auth.resources.limits.cpu" "500m" }}
              memory: {{ .Values | get "overrides.unbind.auth.resources.limits.memory" "2Gi" }}
          containerPort: 8090
          service:
            type: ClusterIP
            port: 8090
          ingress:
            enabled: true
          command: ["/app/oauth2server"]
          env:
            - name: SYSTEM_NAMESPACE
              value: {{ .Values.namespace }}
            - name: EXTERNAL_UI_URL
              value: {{ printf "https://%s" .Values.unbindDomain }}
            - name: EXTERNAL_OAUTH2_URL
              value: {{ printf "https://%s/api/oauth2" .Values.unbindDomain }}
            - name: POSTGRES_HOST
              value: {{ .Values | get "overrides.unbind.auth.database.host" (printf "pg-unbind.%s" .Values.namespace) }}
            - name: POSTGRES_PORT
              value: {{ .Values | get "overrides.unbind.auth.database.port" "5432" | quote }}
            - name: POSTGRES_USER
              valueFrom:
                secretKeyRef:
                  name: {{ .Values | get "overrides.unbind.auth.database.secretName" "unbind.pg-unbind.credentials.postgresql.acid.zalan.do" }}
                  key: username
            - name: POSTGRES_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: {{ .Values | get "overrides.unbind.auth.database.secretName" "unbind.pg-unbind.credentials.postgresql.acid.zalan.do" }}
                  key: password
            - name: DEX_ISSUER_URL
              value: {{ .Values | get "overrides.unbind.auth.dex.issuerUrl" (printf "https://%s/api/dex" .Values.unbindDomain) }}
            - name: DEX_ISSUER_URL_EXTERNAL
              value: {{ .Values | get "overrides.unbind.auth.dex.issuerUrlExternal" (printf "https://%s/api/dex" .Values.unbindDomain) }}
            - name: DEX_CLIENT_ID
              value: {{ .Values | get "overrides.unbind.auth.dex.clientId" "dex-client" }}
            - name: DEX_CLIENT_SECRET
              valueFrom:
                secretKeyRef:
                  name: {{ .Values | get "overrides.unbind.auth.dex.secretName" "dex-client-secrets" }}
                  key: {{ .Values | get "overrides.unbind.auth.dex.secretKey" "connector-oidc-secret" }}
            - name: DEX_CONNECTOR_SECRET
              valueFrom:
                secretKeyRef:
                  name: {{ .Values | get "overrides.unbind.auth.dex.secretName" "dex-client-secrets" }}
                  key: connector-oidc-secret
            - name: REDIS_URL
              value: {{ .Values | get "overrides.unbind.auth.redis.url" (printf "redis-headless.%s:6379" .Values.namespace) }}

      - serviceAccount:
          create: true
          name: unbind-api-sa
          annotations: {}
      - rbac:
          create: true
      - builder:
          rbac:
            create: true
            clusterRoleName: "app-crd-creator"
            clusterRoleBindingName: "app-crd-creator-binding"
          serviceAccount:
            create: true
            name: "builder-serviceaccount"
            annotations: {}

    labels:
      component: unbind-app
    installed: true
